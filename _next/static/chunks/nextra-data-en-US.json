{"/about":{"title":"About","data":{"b5h22-#b5h22 ðŸ‘‹":"","software-developer-in-training#Software Developer in Training":"","a-little-more-about-me#A little more about me...":"const b5h22 = {\n  skills: {\n    languages: [C, C++, Javascript, HTML, CSS],\n    frameworks: [React, NodeJS],\n    databases: [Oracle SQL],\n    tools: [Git, GitHub, VSCode]\n  },\n}"}},"/c/01-basics":{"title":"01 Basics","data":{"basic-c-programming#Basic C Programming":"","features-of-c#Features of C":"C is English-like\nC is quite compact - has a small number of keywords\nC is the lowest in level of the high-level languages\nC can be faster and more powerful than other high-level languages\nC programs that need to be maintained are large in number\nC is used extensively in high-performance computing\nUNIX, Linux and Windows operating systems are written in C and C++","c-compiler#C Compiler":"A C compiler is an operating system program that converts C language statements into machine language equivalents.\n source: https://intro2c.sdds.ca/A-Introduction/compilers#the-c-compiler","c-program-structure#C Program Structure":"#include <stdio.h> // Preprocessor directive\n// #: This symbol at the beginning of a line is used for preprocessor commands.\n// <stdio.h>: This is a header file. (stdio.h stands for \"standard input-output header\")\nint main() { // Function header\n// int main() {: 'int' means that this function will return an integer. \n// 'main()' is a special function that always runs first when your program starts.\n    printf(\"Hello World!\"); // Function body\n    // printf(\"Hello World!\");: 'printf' is a function used to print text on your screen.\n    return 0; // Function footer\n    // 'return' ends the function and sends back (or \"returns\") an integer value\n    //  in this case, 0 indicates that everything went okay.\n}\n// }: This closes off our main function - everything between { and } belongs to main().","escape-sequence--comments#Escape Sequence / Comments":"Escape Sequence\tDescription\t\\n\tLine break\t\\\"\t\"\t\\\\\t\\\t\\t\tTab\t//\tSingle line comment\t/* */\tMulti-line comment"}},"/c/02-types":{"title":"02 Types","data":{"types#Types":"","arithmetic-types-size-range-type-specifier#Arithmetic Types (Size, Range, Type Specifier)":"Data Type\tSize (in bytes)\tRange\tType Specifier\tchar\t1\t-128 to 127 or 0 to 255\t%c\tint\t4\t-2,147,483,648 to 2,147,483,647\t%d\tfloat\t4\tapproximately 6 decimal digits of precision\t%f\tdouble\t8\tapproximately 15 decimal digits of precision\t%lf","variable#Variable":"Declare variable\n// [type] [variable name];\nint age; // declares an integer variable named 'age'\nfloat weight; // declares a float variable named 'weight'\nchar firstLetter; // declares a character variable named 'firstLetter'\nOnce declared, you can assign values to these variables like this:\nage = 20; // assigns the value 20 to 'age'\nweight = 70.5; // assigns the value 70.5 to 'weight'\nfirstLetter = 'A'; // assigns the character A to 'firstLetter'\nYou can also declare and assign values at the same time:\nint age = 20;\nfloat weight = 70.5;\nchar firstLetter = 'A';\nYou may group the identifiers of variables that share the same type within a single declaration by separating the identifiers by commas.\n char   children, digit;\n int    nPages = 10, nBooks = 3, nRooms = 1;\n float  cashFare, height = 185.5, weight = 70.5;\n double loan, mortgage;\nYou can use const keyword to declare a constant. A constant is a type of variable whose value cannot be changed after it's been defined.\nconst int myConstant = 10;","naming-conventions#Naming Conventions":"Start with a letter or an underscore (_).\nUse any mix of letters, numbers, and underscores (_).\nKeep it under 32 characters long.\nDon't use C reserved words","tips-for-good-variable-names#Tips for good variable names":"Make the name explain what it's used for.\nKeep it short but clear.\nMake sure the name matches what data is stored in it.\nThe name should make your code easier to read.\nUse \"camelNotation\" where the first letter of each word is capitalized except the first word (like \"myVariableName\").\nAvoid using underscores (_) because system libraries often use them and you don't want to mix up your variables with theirs."}},"/c/03-simple-calculation":{"title":"03 Simple Calculation","data":{"simple-calculation#Simple Calculation":"","format#Format":"Type\tSpecifier\tintput/output as\tchar\t%c\tcharacter\tint,short\t%d\tdecimal integer\tfloat\t%f\tfloating-point\tdouble\t%lf\tfloating-point\t\nThe default number of decimal places displayed by %f and %lf is 6. To display two decimal places, we write %.2f or %.2lf.","simple-input#Simple input":"The scanf(...) command takes in information from the user and keeps it in a special place in the computer's memory linked to a certain variable in the program.\nscanf(format, address);\naddress: contains the address of the destination variable. use the prefix & to refer to the 'address of' of a variable.","simple-output#Simple output":"The printf(...) command shows the user the value of a certain variable or result of an operation.\nprintf(format, expression);"}},"/c/04-expression":{"title":"04 Expression","data":{"expression#Expression":"","binary-operations#Binary Operations":"Binary arithmetic operations are math actions we can do on whole numbers. These include adding, subtracting, multiplying, dividing and finding the remainder.\nArithmetic Expression\tMeaning\toperand + operand\tadd the operands\toperand - operand\tsubtract the right from the left operand\toperand * operand\tmultiply the operands\toperand / operand\tdivide the left by the right operand\toperand % operand\tremainder of the division of left by right","relational-expressions#Relational Expressions":"C language has six ways to compare things. These comparisons are called relational expressions. They look at two values and decide if a condition is true or not. If it's true, they give back 1; if it's false, they give back 0. The result you get from these comparisons is always an int type.\nRelational Expression\tMeaning\toperand == operand\toperands are equal\toperand > operand\tleft is greater than the right\toperand >= operand\tleft is greater than or equal to the right\toperand < operand\tleft is less than the right\toperand <= operand\tleft is less than or equal to the right\toperand != operand\tleft is not equal to the right","logical-expressions#Logical Expressions":"C language doesn't have special words for true or false. Instead, it sees the number 0 as false and any other number as true. C has three ways to do logical operations. These operations give back 1 if they are true and 0 if they are false. The result you get from these operations is always an int type.\nLogical Expression\tMeaning\toperand && operand\tboth operands are true\toperand || operand\tone of the operands is true\t! operand\tthe operand is not true","demorgans-law#DeMorgan's Law":"DeMorgan's Law is a rule in logic that helps us simplify complex statements. It has two parts:\n\"Not (A and B)\" is the same as \"(Not A) or (Not B)\"\n\"Not (A or B)\" is the same as \"(Not A) and (Not B)\"\nExample:\n// below logically identical\n// example #1\nc = !(a && b)\nc = !a || !b\n// example #2\nc = !a && !b\nc = !(a || b)","binary-operands#Binary operands":"Expression\tShorthand\tLonghand\tMeaning\toperand += operand\ti += 4\ti = i + 4\tadd 4 to i and assign to i\toperand -= operand\ti -= 4\ti = i - 4\tsubtract 4 from i and assign to i\toperand *= operand\ti *= 4\ti = i * 4\tmultiply i by 4 and assign to i\toperand /= operand\ti /= 4\ti = i / 4\tdivide i by 4 and assign to i\toperand %= operand\ti %= 4\ti = i % 4\tremainder after i / 4 then assign to i","unary-operands#Unary Operands":"Expression\tShorthand\tLonghand\tMeaning\t++operand\t++i\ti = i + 1\t(prefix) increment i by 1\toperand++\ti++\ti = i + 1\t(postfix) increment i by 1\t--operand\t--i\ti = i - 1\t(prefix) decrement i by 1\toperand--\ti--\ti = i - 1\t(postfix) decrement i by 1\t\nPrefix does the operation first, then gives you the result.\nPostfix gives you the result first, then does the operation.","type-casting#Type Casting":"Type conversions are supported by the C programming language. In order to convertÂ the type of an operand, you put the target type in parenthesis before the operand. ThisÂ statement is known as a cast.\nint main() {\n    int a = 5, b = 2;\n    printf(\"Result of int division: %d\\n\", a / b); // 2\n    printf(\"Result of double division: %f\\n\", (double)a / b); // 2.5\n    return 0;\n}","mixed-type-expression#Mixed-Type Expression":"Computers use different parts to handle whole numbers and decimal numbers. So, they can only work with calculations that use the same type of numbers. But sometimes, calculations use both types of numbers. So, we need rules to change one type of number into another type for these calculations.\nType\tRank\tlong double\thighest\tdouble\t...\tfloat\t...\tlong long\t...\tlong\t...\tint\t...\tshort\t...\tchar\tlowest\t\nIn a mixed-type expression, lower-ranked types are automatically converted to the type of the highest-ranked operand. This is called \"promotion\".\nint a = 5;\ndouble b = 3.14;\nb = a; // 'a' is automatically promoted to a double\n\"Narrowing\" is the opposite of promotion. It's when a value of a higher-ranked type is assigned to a variable of a lower-ranked type. This can cause a loss of data.\ndouble a = 3.14;\nint b;\nb = a; // 'a' is truncated to an int, so 'b' becomes 3, not 3.14"}},"/c/06-array":{"title":"06 Array","data":{"array#Array":"","definition#Definition":"An array is a type of data structure that can store a fixed-size ordered group of elements of the same type.","elements#Elements":"Each item stored in an array is called an element. These elements are accessed by their numerical index. The first element starts at index 0.\nIn C language, the computer doesn't check if we are trying to access a spot in the array that doesn't exist. So, it's up to us, the programmers, to make sure we don't use an index that is outside the size of the array. If our array has 5 spots, we need to make sure we only try to access spots 0 to 4.","initialization#Initialization":"To initialize an array, you define the type of elements it will hold, the name of the array(identifier), and the size within square brackets. For example:\n// type identifier[size];\nint numbers[5];\nThis means you have an array named 'numbers' that can hold 5 integers.","accessing-elements#Accessing Elements":"Accessing Elements: To access an element in the array, you refer to its index. For example:\nnumbers[0] = 10;\nThis means you're putting the integer '10' in the first spot in the 'numbers' array.","initializing-with-values#Initializing with Values":"You can initialize an array with values at the same time you declare it. Like this:\n// type identifier[ size ] = { value, ... , value };\nint numbers[5] = {1, 2, 3, 4, 5};\nThis means you have an array named 'numbers' that holds five integers, and you've put 1 in the first spot, 2 in the second spot, and so on.\nRemember, arrays in C are zero-indexed, which means the first element is at index 0, the second element is at index 1, and so forth. So if you have an array of size 5, the indices will be 0, 1, 2, 3, and 4.","parallel-arrays#Parallel Arrays":"These are two or more arrays where the related data is stored at the same index in each array. For example:\n#include <stdio.h>\nint main(void)\n{\n    int i;\n    int sku[]      = { 2156, 4633, 3122, 5611};\n    double price[] = { 2.34, 7.89, 6.56, 9.32};\n    const int n    = 4;\n    printf(\"  SKU Price\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%5d $%.2lf\\n\", sku[i], price[i]);\n    }\n    return 0;\n}\nOutput of the above program:\n  SKU Price\n 2156 $2.34\n 4633 $7.89\n 3122 $6.56\n 5611 $9.32\nThe sku[] array holds the key data, while the price[] array holds the value data. Note how the elements of parallel arrays with the same index make up the fields of a single record of information.Parallel arrays are simple to process. For example, once we find the index of the element that matches the specified sku, we also have the index of the unit price for that element.","character-strings#Character Strings":"A string in programming is a sequence of characters, stored in an array, with an extra special character at the end, called the null terminator, represented as '\\0'.\nThis null terminator indicates the end of the string. It's value is always 0, meaning all its bits are zeros.\nThe position of this null terminator also tells us the length of the string. However, the total memory used by the string includes an extra space for this null terminator, so it's one more than the number of actual characters in the string.","syntax#Syntax":"We need to allocate memory for one additional byte to provide room for the null terminator:\nconst int NCHAR = 17;\nchar name[NCHAR + 1] = \"My Name is Arnold\";\nWe use the \"%s\" conversion specifier and the address of the start of the character string to send its contents to standard output:\nprintf(\"%s\", name);"}},"/c/05-logic":{"title":"05 Logic","data":{"logic#Logic":"","structured-programming#Structured programming":"Structured programming is a way of writing code that focuses on making it easy to read and change. It breaks down a program into smaller parts using functions and blocks. It uses three main parts: sequence, selection, and repetition. The aim is to make the code simple and manageable.\nSequence: This is the normal flow where statements are executed line by line in order.\nSelection: This is implemented with control statements like \"if\", \"if-else\", and \"switch\". It allows the program to choose between different paths based on certain conditions.\nRepetition: This is implemented with loops like \"for\", \"while\", and \"do-while\". It allows certain parts of the code to be repeated several times.","preliminary-design#Preliminary Design":"Preliminary Design is the early stage of designing where you create a basic plan of what you want to make, without all the small details.\nPseudocode: It's like a draft of your program, written in simple English. It helps you plan the steps your program will take, without using real code.\nFlowcharts: These are pictures with symbols and arrows that show the steps and flow of your program. They help you see and share your plan before you start coding.","selection-constructs#Selection constructs":"The C language supports three selection constructs:\noptional path\nalternative paths\nconditional expression\nThe flow charts for these three constructs are shown below:","optional-path#Optional Path":"It is a programming term that refers to a part of the code which only runs if a specific condition is met. In other words, this part of the code is optional and only runs when the condition is true.\nif (condition)\n  sequence\nHere, the condition could be a relational expression or a logical expression. The sequence may be a single statement or a code block.","single-statement#Single Statement":"if (likePizza == 1)\n  printf(\"I like pizza\\n\");","code-block-more-than-a-single-statement#Code Block (more than a single statement)":"if (likePizza == 1)\n{\n  printf(\"I like pizza\\n\");\n  printf(\"I want more pizza\\n\");\n}","alternative-paths#Alternative Paths":"The C language supports two ways of describing alternative paths: an binary select construct and a multiple selection construct.","binary-selection#Binary Selection":"if (condition)\n  sequence1\nelse\n  sequence2\nHere, the condition could be a relational expression or a logical expression. The sequence may be a single statement or a code block. The program executes the sequence following the if only if the condition is true. The program executes the sequence following the else only if the condition is false.","single-statement-1#Single Statement":"if (likePizza == 1)\n  printf(\"I like pizza\\n\");\nelse\n  printf(\"I hate pizza\\n\");","code-block-more-than-a-single-statement-1#Code Block (more than a single statement)":"if (likePizza == 1)\n{\n  printf(\"I like pizza\\n\");\n}\nelse\n{\n  printf(\"I hate pizza\\n\");\n  printf(\"I don't want pizza\\n\");\n}","multiple-selection#Multiple Selection":"For three alternative paths, we append an if else construct to the else keyword.\n if (condition)\n  sequence\n else if (condition)\n  sequence\n else\n  sequence\nIf the first condition is true, the program skips the second and third sequences. If the first condition is false, the program skips the first sequence and evaluates the second condition. The program executes the second sequence only if the first condition is false and the second condition is true. The program executes the third sequence and skips the first two only if both conditions are false.","compound-conditions#Compound Conditions":"The condition in a selection construct may be a compound condition. A compound condition takes the form of a logical expression\nif (age > 12 && age < 16)\n{\n  printf(\"Student Fare - no id required\\n\");\n}\nelse if (age > 15 && age < 20)\n{\n  printf(\"Student Fare - id is required\\n\");\n}\nelse if (age < 13)\n{\n  printf(\"Child ride for free!\\n\");\n}\nelse if (age >= 65)\n{\n  printf(\"Senior Fare - id is required\\n\");\n}\nelse\n{\n  printf(\"Adult Fare\\n\");\n}","case-by-case#Case-by-Case":"The \"switch\" structure in programming checks a condition, which can be simple or complex, and matches it with different fixed values or results. Here is how it looks:\nswitch (question)\n{\ncase choice1:\n       do something\n       break;\ncase choice2:\n       do something else\n       break;\ndefault:\n       do another thing\n}\n\"switch\" is like a multi-choice quiz. You have a question (condition) and many choices (cases). If your question matches 'choice1', you will do something. If it matches 'choice2', you will do something else. If it doesn't match any choices, you will do another thing (default). \"break\" means you stop and move on. If there is no \"break\", you will also do the things for the next choice.","conditional-expression#Conditional Expression":"The conditional expression is a ternary operator that takes three operands. It is used to replace an if else construct that assigns a value to a variable based on a condition. The conditional expression has the following form:\ncondition ? expression1 : expression2\nFirst, it checks a condition. If it's true, it uses the first expression, and if it's false, it uses the second. Only the expression that matches the condition is used.\n// Example\nint a = 10, b = 20;\nint max = (a > b) ? a : b;\nIn this example, (a > b) is the condition. If a is greater than b, the expression a is used, and max becomes a. If a is not greater than b, the expression b is used, and max becomes b. Since 20 is greater than 10, in this case, max would become 20.","iteration-constructs#Iteration constructs":"In C programming, there are three ways to repeat actions: 'while', 'do while', and 'for'. Each method needs a set-up step, a condition to check, and a step to change things for the next round. If we forget to change things, or the condition is always true, the action will repeat forever, creating an infinite loop.","while#while":"/*\n  while (condition)\n  {\n      sequence\n  }\n*/\nint i = 1;\nwhile (i <= 5) {\n    printf(\"%d \", i);\n    i++;\n}","do-while#do while":"/*\n  do {\n      sequence\n  } while (condition);\n*/\nint i = 1;\ndo {\n    printf(\"%d \", i);\n    i++;\n} while (i <= 5);","for#for":"/*\n  for (initialization; condition; change)\n  {\n      sequence\n  }\n*/\nfor (int i = 1; i <= 5; i++) {\n    printf(\"%d \", i);\n}\nIn all three examples, the loop prints the numbers 1 to 5. The while loop checks the condition before the loop starts, the do/while loop checks it after the loop runs once, and the for loop includes the initialization, condition, and increment all in one line.","flags#Flags":"Flagging in programming is a technique to follow the single-entry single-exit principle, making loops simpler. Flags, either true or false, control the flow of iterations, deciding whether to continue or stop, so avoiding crossed paths and improving the overall design and maintainability of the code."}},"/c/07-structures":{"title":"07 Structures","data":{"structures#Structures":"The purpose of a structure in C programming is to allow programmers to define custom data types by grouping together various data types under one name. This allows for the creation of more complex data structures that can hold different types of data. Structures provide a way to organize and manage related data efficiently.","declaration#Declaration":"struct Tag\n{\n    [type] [identifier];\n    // ... other types\n};\nstruct keyword is used to declare a structure.\nTag is the name of the structure.\nInside the curly braces  you list the types of data that will be in your structure. Each data type in the structure is called a \"member\" or \"field\".\ntype is the data type of the member. It can be any valid C data type, like int, float, or even other structures.\nidentifier is the name of the member that you will use to access the member's value.","initialization#Initialization":"To set up a new structure variable with starting values in C, we use braces  with a list of values inside. These values are separated by commas and must be in the same order as the members in the structure. This is how we do it:\nstruct Tag identifier = { value, ... , value };","member-acces#Member Acces":"To access a member of an object of a structure, we use the dot operator (.). Dot notation takes the form:\nobject.member\nTo access an element of an array member, we use subscript notation\nobject.member[index]"}},"/c/08-function":{"title":"08 Function","data":{"function#Function":"","modular-design#Modular Design":"A design method that divides a system into smaller parts (modules) which can be independently created and then fit together.\nSome general guidelines for defining a module include:\nThe module is easy to upgrade.\nThe module contains a readable amount of code.\nThe module may be used as part of the solution to some other problem.\nFor a structured design, we stipulate that each module has one entry point and one exit point, each module is highly cohesive, and each module exhibits low coupling.","cohesion#Cohesion":"It refers to how closely all the routines in a module support a central purpose. High cohesion means each module has a single, well-defined task.","coupling#Coupling":"It refers to the interdependence between modules. Loose coupling means each module is independent as much as possible.\nA better design is one that has high cohesion (each module does one thing well) and loose coupling (each module is independent).","functions#Functions":"","definition#Definition":"A function in C is a block of code that performs a specific task. It is the building block of modular programming.","basic-syntax#Basic Syntax":"Function Definition: It includes the function's name, return type and parameters.\n// function declaration\nreturn_type function_name(parameter1, parameter2, ...){\n    // code\n    return value;\n}\nFunction Call: It includes the function's name and arguments.\n// function call\nfunction_name(argument1, argument2, ...);","pass-by-value#Pass by Value":"In C, arguments are passed to functions by value. It means that a copy of the data is made and used inside the function, not affecting the original data.","type-mismatch-in-arguments-and-parameters#Type Mismatch in Arguments and Parameters":"If the type of an argument does not match the type of the corresponding parameter in the function definition, the C compiler will try to convert the argument to the type of the parameter. If this is not possible, an error will occur."}},"/cpp/01-basics":{"title":"01 Basics","data":{"object-oriented-programming#Object-Oriented Programming":"","features-of-oop#Features of OOP":"OOP is a programming paradigm that uses \"objects\" to design applications and computer programs.\nOOP allows the programmer to create an object that combines data and functionality.\nData often known as attributes or properties, and functionality often known as methods or behaviors.\nOOP makes it easy to map real-world problems and solutions.","oop-concepts#OOP Concepts":"Class: A blueprint for creating objects.\nObject: An instance of a class.\nInheritance: Reusing an already existing design to design a better object.\nPolymorphism: Doing the same thing in different ways.\nEncapsulation: Packing the data and behavior together.\nAbstraction: Focusing on what needs to be done and ignore the irrelevant aspects of the problem.","features-of-c#Features of C++":"C++ is a superset of the C language.\nA multi-paradigm programming language that supports procedural(can focus on distinct activities) and object-oriented(can focus on distinct objects).\nrealistic, efficient, and flexible enough for demanding projects.","c-compiler#C++ Compiler":"A C++ compiler is an operating system program that converts C++ language statements into machine language equivalents.","stages-of-compilation#Stages of Compilation":"Preprocessing: The preprocessor processes directives in the source code, such as #include for header files and #define for macro definitions, before it is passed to the compiler.\nCompilation: The compiler translates the preprocessed source code into object code in binary format.\nLinking: The linker combines the object files generated by the compiler into a single executable file.\n source: https://intro2oop.sdds.ca/A-Introduction/modular-programming#modules","modular-programming#Modular Programming":"Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules.\nEach module contains everything necessary to execute a specific aspect of the desired functionality.\nThe modules can be developed, tested, and maintained independently.","modular-programming-in-c#Modular Programming in C++":"In C++, a module is implemented using a header file and a source file.\nThe header file contains the declarations of the functions and variables in the module.\nThe source file contains the definitions of the functions and variables in the module.","namespace#namespace":"A namespace is a declarative region that provides a scope for the identifiers declared within it.\nNamespaces are used to organize the code into logical groups and prevent naming conflicts.\nThe namespace keyword is used to define a namespace.\nnamespace my_namespace {\n    int x;\n    void foo();\n}"}},"/cpp/02-foundations":{"title":"02 Foundations","data":{"types#Types":"","fundamental-types#Fundamental Types":"Integral Types (store data exactly in equivalent binary form and can be signed or unsigned)\nbool - stores a logical value (true or false)\nchar\nint - short, long, long long\nFloating Point Types (store data to a specified precision - can store very small and very large values)\nfloat\ndouble - long double","compound-types#Compound Types":"Array (store multiple values of the same type)\nPointer (store the memory address of another variable)\nReference (alias to another variable)\nClass/Structure (store multiple values of different types)","scope#Scope":"The scope of a variable is the region of the program where the variable is accessible.\nglobal scope - visible to the entire program\nfile scope - visible to the source code within the file\nfunction scope - visible to the source code within the function\nclass scope - visible to the member functions of the class\nblock scope - visible to the code block","shadowing#Shadowing":"Shadowing occurs when a variable in an inner scope has the same name as a variable in an outer scope.\n#include <iostream>\nusing namespace std;\nint x = 10; // global variable\nint main() {\n    int x = 20; // local variable\n    cout << x << endl; // Output: 20\n    return 0;\n}","overloading#Overloading":"Function overloading allows multiple functions with the same name but different parameters. The compiler determines which function to call based on the number and types of arguments.\n#include <iostream>\nusing namespace std;\nvoid print(int x) {\n    cout << \"Integer: \" << x << endl;\n}\nvoid print(double x) {\n    cout << \"Double: \" << x << endl;\n}\nint main() {\n    print(10); // Output: Integer: 10\n    print(3.14); // Output: Double: 3.14\n    return 0;\n}","prototype#Prototype":"A function prototype is a declaration of a function that tells the compiler about the function's name, return type, and parameters.\n#include <iostream>\nusing namespace std;\nvoid print(int x); // function prototype\nint main() {\n    print(10); // Output: 10\n    return 0;\n}\n// function definition\nvoid print(int x) {\n    cout << x << endl;\n}","default-arguments#Default Arguments":"Default arguments are used to provide a default value for a function parameter if no argument is passed.\n#include <iostream>\nusing namespace std;\nvoid print(int x, int y = 0) {\n    cout << \"x: \" << x << \", y: \" << y << endl;\n}\nint main() {\n    print(10); // Output: x: 10, y: 0\n    print(10, 20); // Output: x: 10, y: 20\n    return 0;\n}","references#References":"A reference is an alias to another variable. It allows you to work with the original variable directly.\nA reference must be initialized when declared.\nA reference cannot be null and re-assigned to refer to another variable.\n& is used to declare a reference.\n#include <iostream>\nusing namespace std;\nint main() {\n    int x = 10;\n    int &y = x; // reference to x\n    y = 20; // changes the value of x\n    cout << x << endl; // Output: 20\n    return 0;\n}","array-of-pointers#Array of Pointers":"An array of pointers is an array where each element is a pointer to another variable.\n#include <iostream>\nusing namespace std;\nint main() {\n    int x = 10, y = 20, z = 30;\n    int *arr[3] = {&x, &y, &z}; // array of pointers\n    cout << *arr[0] << endl; // Output: 10\n    cout << *arr[1] << endl; // Output: 20\n    cout << *arr[2] << endl; // Output: 30\n    return 0;\n}"}},"/c/09-pointer":{"title":"09 Pointer","data":{"pointers#Pointers":"","what-is-a-pointer#What is a pointer?":"A pointer is a variable that stores the address of another variable.\nIt is used to store the memory address of a variable.","why-use-pointers#Why use pointers?":"To access the memory address of a variable.\nTo access the value of a variable indirectly.\nTo pass arguments by reference.\nTo return multiple values from a function.\nTo allocate memory dynamically.","pointer-declaration#Pointer Declaration":"The declaration of a pointer is similar to the declaration of a variable.\nThe data type of a pointer must be the same as the data type of the variable it points to.\nThe pointer declaration is done by adding an asterisk (*) before the pointer name.\nint *ptr;","pointer-initialization#Pointer Initialization":"A pointer can be initialized with the address of a variable.\nThe address of a variable can be obtained by using the address-of operator (&).\nint num = 10;\nint *ptr = &num;","pointer-dereferencing#Pointer Dereferencing":"Dereferencing a pointer means accessing the value of the variable it points to.\nThe value of a variable can be accessed by using the dereference operator (*).\nint num = 10;\nint *ptr = &num;\nprintf(\"%d\", *ptr); // Output: 10","pointer-arithmetic#Pointer Arithmetic":"Pointer arithmetic is used to perform arithmetic operations on pointers.\nThe arithmetic operations include addition, subtraction, increment, and decrement.\nThe size of the data type is taken into account when performing arithmetic operations.\nint arr[5] = {1, 2, 3, 4, 5};\nint *ptr = arr;\nprintf(\"%d\", *ptr); // Output: 1\nptr++;\nprintf(\"%d\", *ptr); // Output: 2","pass-by-value#Pass-by-value":"In C, arguments are passed to functions by value.\nIt means that a copy of the data is made and used inside the function, not affecting the original data.\nvoid increment(int num){\n  num++;\n}\nint num = 10;\nincrement(num);\nprintf(\"%d\", num); // Output: 10","pass-by-reference#Pass-by-reference":"Pointers can be passed as arguments to functions.\nPassing a pointer as an argument allows the function to modify the value of the variable it points to.\nvoid increment(int *ptr){\n    (*ptr)++;\n}\nint num = 10;\nincrement(&num);\nprintf(\"%d\", num); // Output: 11","pointer-to-array#Pointer to Array":"A pointer to an array is a pointer that stores the address of the first element of an array.\nIt is used to access the elements of an array using pointer arithmetic.\nint arr[5] = {1, 2, 3, 4, 5};\nint *ptr = arr;\nprintf(\"%d\", *ptr); // Output: 1\nptr++;\nprintf(\"%d\", *ptr); // Output: 2","pointer-to-structure#Pointer to Structure":"A pointer to a structure is a pointer that stores the address of a structure.\nIt is used to access the members of a structure using the arrow operator (->).\nstruct Point{\n    int x;\n    int y;\n};\nstruct Point p = {10, 20};\nstruct Point *ptr = &p;\nprintf(\"%d\", ptr->x); // Output: 10\nprintf(\"%d\", ptr->y); // Output: 20","null-pointer#Null Pointer":"A null pointer is a pointer that does not point to any memory location.\nIt is used to indicate that the pointer is not pointing to a valid memory address.\nIt is represented by the constant NULL.\nint *ptr = NULL;\nif(ptr == NULL){\n    printf(\"Null Pointer\");\n}"}},"/cpp/06-polymorphism":{"title":"06 Polymorphism","data":{}},"/error-notes/c/01-scanf":{"title":"01 Scanf","data":{"c-error-notes#C Error Notes":"","problems-with-c#Problems with %c":"scanf() only takes the characters it needs from the buffer, but this can cause issues when using %c. Consider the following program. When scanf() reads an integer, it leaves behind a newline character ('\\n') in the input buffer. The next time scanf() is called with %c, it thinks this leftover '\\n' is the input character. Because of this, the program never gets to read the tax status input from the buffer.\nBuffer?  A buffer is like a temporary storage spot in a computer's memory. It holds data for a short time while it's being moved from one place to another.\n#include <stdio.h>\nint main(void)\n{\n    int items;\n    char status; // tax status g or p\n    printf(\"Number of items : \");\n    scanf(\"%d\", &items);\n    printf(\"Status : \");\n    scanf(\"%c\", &status);   // ERROR: assigns \\n to variable 'status'\n                            //        and will not pause for user input\n    printf(\"%d items (%c)\\n\", items, status);\n    return 0;\n}\nThe above program produces the following output:\nNumber of items : 25\nStatus : 25 items (\n)\nNotice how the newline character ('\\n') (which was assigned to the tax status variable) places the closing parenthesis on a newline.\nMethod-1:\nscanf(\"%d\", &items);\nscanf(\"%c%c\", &junk, &status); // store one character in junk first\nMethod-2:\nscanf(\"%d\", &items);\nscanf(\"%*c%c\", &status);       // discard(ignore) one character first\nMethod-3:\nscanf(\"%d\", &items);\nscanf(\" %c\", &status);         // discard(ignore) all whitespace first\nMethod-4:\nscanf(\"%d%*c\", &items);        // discard(ignore) newline ('\\n')\nscanf(\"%c\", &status);\nMethod-5:\nscanf(\"%d\", &items);\nclear();                       // call a custom function to clear the buffer\nscanf(\"%c\", &status);"}},"/cpp/03-dynamic-memory":{"title":"03 Dynamic Memory","data":{"memory#Memory":"The memory available to an application at run-time consists of static memory and dynamic memory","static-memory#Static Memory":"The memory that the operating system allocates for the application at load time is called static memory.\nStatic memory lasts the lifetime of the application\nThe linker determines the amount of static memory used by the application","dynamic-memory#Dynamic Memory":"The operating system provides dynamic memory to an application at run-time upon request\nDynamic memory is allocated on the heap (a region of memory that is not managed by the operating system)","lifetime#lifetime":"The lifetime of dynamic memory is determined by the application\nThe application is responsible for releasing the memory when it is no longer needed\nIf the application fails to release the memory, it results in a memory leak","dynamic-memory-allocationdeallocation#Dynamic Memory Allocation/Deallocation":"The new operator is used to allocate memory on the heap\nThe delete operator is used to release memory allocated by new\nThe address of the allocated memory is stored in a pointer variable (static memory)\nAllocated memory must be deallocated within the scope of the pointer that holds its address\n#include <iostream>\nusing namespace std;\nint main() {\n    // allocate memory for an integer\n    int* p = new int;\n    *p = 10;\n    cout << *p << endl;\n    // release memory\n    delete p;\n    return 0;\n}","memory-leaks#Memory Leaks":"A memory leak occurs when the application fails to deallocate memory that is no longer needed\nThe pointer to dynamic memory goes out of scope before the application deallocates that memory\nThe pointer to dynamic memory changes its value before the application deallocates the memory starting at the address stored in that pointer"}},"/cpp/04-encapsulation":{"title":"Encapsulation","data":{"":"Encapsulation is a concept in object-oriented programming where the internal state (data) of an object is hidden from the outside world and can only be accessed through public methods.\nEncapsulation helps to protect the internal state of an object from unintended changes and misuse. It also makes the code more modular and easier to maintain.\nExample:\nclass Rectangle {\nprivate:\n    int width, height;  // Internal state is hidden\npublic:\n    void setWidth(int w) { width = w; }  // Public method to set width\n    void setHeight(int h) { height = h; }  // Public method to set height\n    int area() { return width * height; }  // Public method to get area\n};\nint main() {\n    Rectangle rect;\n    rect.setWidth(5);\n    rect.setHeight(4);\n    std::cout << \"Area: \" << rect.area() << std::endl;  // Outputs: Area: 20\n    return 0;\n}\nIn this example, the width and height of the Rectangle are private, meaning they can't be accessed directly from outside the class. Instead, you use the public methods setWidth and setHeight to change these values and area to compute the area. This ensures that the internal state is controlled and protected.","member-functions#Member Functions":"Member functions are functions that belong to a class and have access to its private and protected members.\nThey are used to provide a controlled interface to the class's data. This ensures that the class's internal state can only be altered in well-defined ways, maintaining the integrity of the data.\nExample:\nclass Rectangle {\n    private:\n        int width, height;\n    public:\n        void setWidth(int w) { width = w; }\n        void setHeight(int h) { height = h; }\n        int area() { return width * height; }\n};\nIn this Rectangle class example, setWidth and setHeight are member functions that allow you to safely set the values of width and height, which are private and thus inaccessible directly from outside the class. The area function calculates the area of the rectangle using these private values. This setup ensures that the rectangle's dimensions can only be modified in controlled ways, maintaining data integrity.","member-operators#Member Operators":"Member operators are special member functions that are defined to work with the syntax of operators. They can be overloaded to perform custom operations.\nThey provide a way to extend the syntax of existing C++ operators to work with user-defined types, allowing for more intuitive code.\nExample:\nclass Counter {\n    private:\n        int value;\n    public:\n        Counter() : value(0) {}\n        Counter& operator++() {\n            ++value;\n            return *this;\n        }\n        int getValue() const { return value; }\n};\nThe Counter class demonstrates how to overload the increment operator (++) as a member function. This allows the Counter object to be incremented using the ++ operator in a natural way, similar to built-in types. The getValue function provides a safe way to access the private value member. This example shows how custom behaviors can be defined for standard operations, enhancing code intuitiveness.","privacy-access-specifiers#Privacy (Access Specifiers)":"Privacy in C++ is enforced through access specifiers (private, protected, public), which control the accessibility of class members.\nThey are crucial for encapsulation, allowing the class to hide its internal state and behavior from outside access, exposing only what is necessary.\nExample:\nclass BankAccount {\n    private:\n        double balance;\n    public:\n        void deposit(double amount) { balance += amount; }\n        double getBalance() const { return balance; }\n};\nIn the BankAccount class, the balance is private, ensuring it cannot be directly modified from outside the class. This protects the balance from unauthorized changes. Public functions deposit and getBalance provide controlled access to modify and read the balance, respectively. This setup exemplifies how encapsulation safeguards the object's state while still allowing necessary external interactions.","construction-and-destruction#Construction and Destruction":"Constructors and destructors are special member functions used for initializing and cleaning up objects.\nConstructors ensure an object starts in a valid state, and destructors allow for any necessary cleanup when an object is destroyed, such as releasing resources.\nExample:\nclass Example {\n    public:\n        Example() { std::cout << \"Constructed\\n\"; }\n        ~Example() { std::cout << \"Destroyed\\n\"; }\n};\nThe Example class has a constructor and a destructor, which are automatically called when an object of the class is created and destroyed, respectively. The constructor initializes the object (in this case, simply announces its creation), and the destructor cleans up (announces its destruction). This example illustrates how constructors and destructors ensure objects are properly initialized and cleaned up, managing resources efficiently.","rule-of-three#Rule of Three":"The Rule of Three states that if a class defines one of the following, it should probably explicitly define all three: destructor, copy constructor, and copy assignment operator.\nTo ensure that copies and destruction of objects handle dynamically allocated resources correctly, preventing resource leaks and shallow copies.\nExample:\nclass StringWrapper {\n    private:\n        char* str;\n    public:\n        StringWrapper(const char* s);  // Constructor\n        ~StringWrapper();              // Destructor\n        StringWrapper(const StringWrapper&); // Copy constructor\n        StringWrapper& operator=(const StringWrapper&); // Copy assignment\n};\nThe StringWrapper class demonstrates the Rule of Three by defining a destructor, copy constructor, and copy assignment operator. These ensure that when StringWrapper objects are copied or destroyed, the dynamic memory allocated for str is correctly managed, preventing memory leaks and ensuring deep copies. This example highlights the importance of proper resource management in classes that handle resources like dynamic memory.","helper-functions#Helper Functions":"Helper functions are non-member functions that perform auxiliary tasks for a class, often used to operate on or with the class's public interface.\nThey improve the readability and maintainability of code by separating complex operations from class definitions, keeping classes focused on their primary responsibilities.\nExample:\nclass Data {\n    public:\n        void processData() { /* ... */ }\n};\nvoid processWithHelper(Data& data) {\n    // Helper function that uses Data's public interface\n    data.processData();\n}\nThe function processWithHelper operates on an object of the Data class. It is a non-member function that utilizes the public interface of Data (processData method) to perform some operation. This separation of concerns allows Data to focus on its primary responsibilities, while processWithHelper handles a specific task, improving code organization and readability."}},"/error-notes/cpp/01-Wsign-compare":{"title":"01 Wsign Compare","data":{"c-error-notes#C++ Error Notes":"","-wsign-compare-warning-error#-Wsign-compare warning error":"","issue#Issue":"Comparison between signed and unsigned integer expressions.","details#Details":"The issue at each line is in the for loop where 'i < size'. Here, 'i' is an unsigned integer (size_t) while the expression 'size - 1' or 'size' could potentially be a signed integer.\nfor (size_t i = 0; i < size - 1; i++) { ... }\nfor (size_t i = 0; i â€¹ size; i++) { ... }","solution#Solution":"To fix these warning errors, consider changing the type of 'size' to unsigned or use a type casting to ensure 'size' and 'i' are of the same type. Always remember to carefully handle the types of variables to avoid such mismatches."}},"/cpp/05-inheritance":{"title":"Inheritance","data":{"":"Inheritance is a mechanism where a new class, known as a derived class, is formed from an existing class, the base class, inheriting its attributes and behaviors.\nIt promotes code reuse, simplifies code maintenance, and establishes a natural hierarchy for objects.\nExample:\nclass Animal {\npublic:\n    void eat() { /* Implementation */ }\n};\nclass Dog : public Animal {};\nDog inherits from Animal, which means Dog can perform eat behavior available to Animal.","derived-class#Derived Class":"A class that inherits from another class. It's also known as a subclass or child class.\nTo extend or modify the behavior of the base (parent) class.\nExample:\nclass Bird : public Animal {\npublic:\n    void fly() { /* Implementation */ }\n};\nBird is a derived class of Animal and adds a new behavior, fly, while still having access to the Animal's behaviors like eat.","access#Access":"Determines how the members (attributes and methods) of a class can be accessed in hierarchy structures.\nTo control the visibility of class members and protect the object's state from unintended modifications.\nPrivate: Bars all access\nProtected: Limits access to derived classes only\nPublic: Unlimited access\nExample:\nclass Base {\nprivate:\n    int value;\npublic:\n    void setValue(int v) { value = v; }\n};\nclass Derived : public Base {};\nIn Base, value is private and cannot be directly accessed by Derived. However, Derived can use the public method setValue to modify value.","shadowing#Shadowing":"Occurs when a derived class declares a variable, function, or property with the same name as one in the base class, hiding the base class version.\nTo override or modify the behavior or value of the base class members in the derived class.\nExample:\nclass Base {\npublic:\n    int number = 5;\n};\nclass Derived : public Base {\npublic:\n    int number = 10; // Shadowing Base's number\n};\nDerived has its own number variable which shadows the number variable of the Base, leading to Derived's number taking precedence within its scope.","initialization-order-constructor-destructor#Initialization Order (constructor, destructor)":"Specifies the order in which constructors and destructors of base and derived classes are called.\no ensure that base class constructors initialize member variables before derived class constructors use them, and that resources are released in the reverse order of their acquisition.\nExample:\nclass Base {\npublic:\n    Base() { /* Initialization code */ }\n    ~Base() { /* Cleanup code */ }\n};\nclass Derived : public Base {\npublic:\n    Derived() { /* Initialization code */ }\n    ~Derived() { /* Cleanup code */ }\n};\nWhen creating a Derived object, the Base constructor is called first, followed by the Derived constructor. Upon deletion, the Derived destructor is called first, then the Base destructor.","passing-arguments-to-a-base-class-constructor#Passing Arguments to a Base Class Constructor":"Mechanism to initialize a base class using specific arguments when constructing a derived class.\nTo allow derived classes to pass initialization data to the base class constructor, ensuring proper initialization of base class members.\nExample\nclass Base {\npublic:\n    Base(int value) { /* Use value for initialization */ }\n};\nclass Derived : public Base {\npublic:\n    Derived(int value) : Base(value) { /* Derived class initialization */ }\n};\nDerived class takes an int value in its constructor and passes it to the Base class constructor. This ensures that Base is initialized with value before Derived performs its own initialization."}},"/error-notes/cpp/02-Wreorder-warning":{"title":"02 Wreorder Warning","data":{"c-error-notes#C++ Error Notes":"","-wsign-compare-warning-error#-Wsign-compare warning error":"","issue#Issue":"Member initialization order in the constructor does not match the order of member declaration in the class.","details#Details":"This warning is triggered when the initialization order of class members in the constructor's initializer list is different from the order in which they were declared within the class. The C++ standard specifies that members are initialized in the order they are declared in the class, not the order specified in the initializer list. This can lead to unexpected behaviors, especially when one member's initialization depends on another.\nclass MyClass {\n  int x;\n  int y;\npublic:\n  MyClass() : y(0), x(y + 1) {} \n  // Warning here because x is declared before y in the class\n};","solution#Solution":"To resolve this warning, simply adjust the order of member initializations in the constructor's initializer list to match the declaration order in the class."}},"/error-notes/cpp/04-memory-leak":{"title":"04 Memory Leak","data":{"c-error-notes#C++ Error Notes":"","memory-leak-error#Memory Leak error":"","issue#Issue":"Failure to deallocate dynamically allocated memory, leading to a gradual depletion of available memory.","details#Details":"Memory leaks occur when dynamically allocated memory is not released back to the system after it is no longer needed. This often happens when the new operator is used to allocate memory, but the corresponding delete operator is not called to free the memory.\nvoid func() {\n    int* ptr = new int;\n    // Memory allocated but not deallocated\n}","solution#Solution":"To prevent memory leaks, always pair each call to new with a corresponding call to delete."}},"/error-notes/cpp/05-linker-error":{"title":"05 Linker Error","data":{"c-error-notes#C++ Error Notes":"","linker-error#Linker error":"","issue#Issue":"Using extern variables in a header file without providing a definition in any source file.","details#Details":"When an extern variable is declared in a header file but not defined in any source file, the linker will generate an error indicating that the variable is undefined. extern specifies that the variable has external linkage, meaning it is defined in another translation unit. However, if the definition is missing, the linker cannot resolve the reference.Example:\nHeader File (example.h):\nextern int myVar; // Declaration of myVar\nSource File (main.cpp):\n#include \"example.h\"\nint main() {\n    myVar = 10; // Linker error: undefined reference to `myVar`\n    return 0;\n}","solution#Solution":"To fix this error, ensure that the extern variable is defined in exactly one source file. The definition allocates storage for the variable and provides an initial value if desired.\nHeader File (example.h):\nextern int myVar; // Declaration of myVar\nSource File (example.cpp):\n#include \"example.h\"\nint myVar = 0; // Definition and initialization of myVar\nBy providing the definition in a source file, the linker can correctly resolve the reference to the extern variable, and the program will compile and link successfully."}},"/error-notes/cpp/03-segmentation-fault":{"title":"03 Segmentation Fault","data":{"c-error-notes#C++ Error Notes":"","segmentation-fault-segmentation-violation-error#Segmentation Fault (Segmentation violation) error":"","issue#Issue":"Accessing memory that is not allocated or accessing memory outside the bounds of an allocated block.","details#Details":"This error often occurs when dereferencing a null pointer or accessing an array index beyond its bounds. For example:\nint* ptr = nullptr;\n*ptr = 10; // Dereferencing a null pointer\nint arr[5];\narr[5] = 10; // Accessing memory outside the bounds of the array","solution#Solution":"To avoid segmentation faults, ensure pointers are properly initialized before use and verify array indices are within bounds before accessing elements."}},"/":{"title":"Dev notes","data":{"":"These are the notes from my journey in learning software development.\nPlease note that these notes are personally curated, and there may be errors. If you find any, I would appreciate it if you could submit a pull request or open an issue to help me improve the content.","table-of-contents#Table of Contents":"","c#C":"01-Basics\n02-Types\n03-Simple Calculation\n04-Expression\n05-Logic\n06-Array\n07-Structures\n08-Function\n09-Pointer","c-1#C++":"01-Basics\n02-Foundations\n03-Dynamic Memory\n04-Encapsulation\n05-Inheritance","react#React":"01-HTML Attribute Conversion: From HTML to JSX","javascript-challenge#JavaScript Challenge":"01-Addition of Fractions","leetcode#LeetCode":"11. Container With Most Water\n151. Reverse Words in a String\n238. Product of Array Except Self\n283. Move Zeroes\n334. Increasing Triplet Subsequence\n345. Reverse Vowels of a String\n392. Is Subsequence\n443. String Compression\n605. Can Place Flowers\n643. Maximum Average Subarray I\n1004. Max Consecutive Ones III\n1071. Greatest Common Divisor of Strings\n1431. Kids With the Greatest Number of Candies\n1456. Maximum Number of Vowels in a Substring of Given Length\n1493. Longest Subarray of 1s After Deleting One Element\n1679. Max Number of K-Sum Pairs\n1768. Merge Strings Alternately","error-notes#Error Notes":"","c-2#C":"01-scanf","c-3#C++":"01-Wsign compare\n02-Wreorder warning\n03-Segmentation Fault\n04-Memory Leak\n05-Linker Error"}},"/js-challenge/01-addition-of-fractions":{"title":"01-addition-of-fractions","data":{"problem-description#Problem Description":"You are given four parameters: numer1 and denom1, representing the numerator and the denominator of the first fraction, and numer2 and denom2, representing the numerator and the denominator of the second fraction. Your task is to complete a function called 'solution'. This function should add the two fractions and express the result as a simplified fraction. The function should then return an array containing the numerator and denominator of the result in that order.","constraints#Constraints":"All parameters (numer1, denom1, numer2, denom2) are greater than 0 and less than 1,000.","inputoutput-examples#Input/Output Examples":"numer1\tdenom1\tnumer2\tdenom2\tresult\t1\t2\t3\t4\t[5, 4]\t9\t2\t1\t3\t[29, 6]","explanation-of-inputoutput-examples#Explanation of Input/Output Examples":"Example #1\n1 / 2 + 3 / 4 equals 5 / 4. Therefore, you should return [5, 4].\nExample #2\n9 / 2 + 1 / 3 equals 29 / 6. Therefore, you should return [29, 6].","my-solution#My Solution":"function solution(numer1, denom1, numer2, denom2) {\n  // Calculate denominator and numerator of the sum\n  let numer = numer1 * denom2 + numer2 * denom1;\n  let denum = denom1 * denom2;\n  \n  // Start checking for common divisor from the smallest of the two numbers\n  let divisor = denom < numer ? denom : numer;\n  \n  // Loop from the largest possible divisor down to 1\n  while (true) {\n    // If divisor is a common divisor of both numerator and denominator\n    if (denum % divisor === 0 && numer % divisor === 0) {\n      return [numer / divisor, denum / divisor];\n    }\n    // If not, decrement the divisor and try again\n    divisor--;\n  }\n}"}},"/leetcode/1071-greatest-common-divisor-of-strings":{"title":"1071. Greatest Common Divisor of Strings","data":{"description#Description":"For two strings s and t, we say \"t divides s\" if and only if s = t + t + t + ... + t + t (i.e., t is concatenated with itself one or more times).Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.","example-1#Example 1:":"Input: str1 = \"ABCABC\", str2 = \"ABC\"\n  Output: \"ABC\"","example-2#Example 2:":"Input: str1 = \"ABABAB\", str2 = \"ABAB\"\n  Output: \"AB\"","example-3#Example 3:":"Input: str1 = \"LEET\", str2 = \"CODE\"\n  Output: \"\"","solution-from-others#Solution from others":"/**\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nvar gcdOfStrings = function(str1, str2) {\n  // if the two strings are not equal, then return empty string\n  if (str1 + str2 !== str2 + str1) {\n      return '';\n  }\n  // Find the greatest common divisor of the two strings using Euclidean algorithm\n  // Replacing the divisor with the remainder and repeating this until the remainder is zero\n  // If remainder equals 0 then it is the GCD of the two numbers\n  const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\n  // return the substring of the first string from 0 to the gcd of the two strings\n  return str1.slice(0, gcd(str1.length, str2.length));\n};"}},"/leetcode/1431-kids-with-the-greatest-number-of-candies":{"title":"1431. Kids With the Greatest Number of Candies","data":{"description#Description":"There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.Note that multiple kids can have the greatest number of candies.","example-1#Example 1:":"Input: candies = [2,3,5,1,3], extraCandies = 3\n  Output: [true,true,true,false,true] \n  Explanation: If you give all extraCandies to:\n  - Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n  - Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n  - Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n  - Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n  - Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.","example-2#Example 2:":"Input: candies = [4,2,1,1,2], extraCandies = 1\n  Output: [true,false,false,false,false] \n  Explanation: There is only 1 extra candy.\n  Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.\nExample 3:\n  Input: candies = [12,1,12], extraCandies = 10\n  Output: [true,false,true]","constraints#Constraints:":"n == candies.length\n2 <= n <= 100\n1 <= candies[i] <= 100\n1 <= extraCandies <= 50","my-solution#My Solution":"/**\n * @param {number[]} candies\n * @param {number} extraCandies\n * @return {boolean[]}\n */\nvar kidsWithCandies = function(candies, extraCandies) {\n    // find the greatest number of candies\n    let greatest = Math.max(...candies);\n    // Check if each kid has the greatest number among the kids\n    let result = candies.map(candy => candy + extraCandies >= greatest);\n    return result;\n};","explanation#Explanation":"Find Greatest: First, find the highest number of candies any kid has.\nCheck Each Kid: Look at how many candies each kid has.\nAdd Extra: Add the extra candies to each kid's current candies.\nCompare: Check if, after adding the extra candies, a kid has as many or more candies than the kid with the most candies.\nMake a List: Create a list where each entry is either true or false. True means that, with the extra candies, the kid could have the highest number of candies.\nResult: Return the list showing which kids could have the most candies with the extra candies added."}},"/leetcode/1004-max-consecutive-ones-iii":{"title":"1004. Max Consecutive Ones III","data":{"description#Description":"Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.","example-1#Example 1:":"Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n  Output: 6\n  Explanation: [1,1,1,0,0,1,1,1,1,1,1]\n  Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.","example-2#Example 2:":"Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\n  Output: 10\n  Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\n  Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.","constraints#Constraints:":"1 <= nums.length <= 105\n  nums[i] is either 0 or 1.\n  0 <= k <= nums.length","solution-from-others#Solution from others":"// using sliding window\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nfunction longestOnes(nums, k) {\n  let left = 0; // Initialize the left boundary of the window\n  let right; // Initialize the right boundary of the window\n  let maxLen = 0; // Variable to store the maximum length of consecutive 1's\n  for (right = 0; right < nums.length; right++) {\n    // If the current number is 0, decrement k\n    if (nums[right] === 0) {\n      k--;\n    }\n    // If k becomes negative, i.e., we have flipped more than k 0's to 1's\n    // Move the left boundary of the window to the right, adjusting k accordingly\n    while (k < 0) {\n      if (nums[left] === 0) {\n        k++;\n      }\n      left++;\n    }\n    // Update the maximum length of consecutive 1's\n    // The size of the current window is right - left + 1\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  return maxLen;\n}","explanation#Explanation":"Goal: This function aims to find the longest stretch of consecutive 1s in an array after flipping at most k zeros to 1s.\nInputs:\nnums: An array of 1s and 0s.\nk: The maximum number of 0s that can be flipped to 1s.\nInitial Setup:\nleft: Marks the starting point of our current window of numbers.\nright: This will mark the end of our current window as we iterate through the array.\nmaxLen: Tracks the longest sequence of 1s we've found so far.\nIterating Through the Array: With a for-loop, we examine each element in the nums array from start to end (right goes from 0 to the end of the array).\nHandling 0s:\nEach time we encounter a 0 (nums[right] === 0), we reduce k by 1 because we're \"using up\" one of our allowed flips.\nIf k becomes negative, it means we've flipped more 0s than allowed. To fix this, we move the left boundary of our window to the right until k is no longer negative, effectively \"unflipping\" a 0 back to its original state if necessary.\nCalculating the Max Length: After each iteration (move of the right boundary), we calculate the size of the current window (right - left + 1) and update maxLen if this window is larger than any we've seen before.\nResult: Once we've examined all elements in the array, the function returns maxLen, the size of the longest sequence of 1s possible with up to k flips from 0 to 1."}},"/leetcode/11-container-with-most-water":{"title":"11. Container With Most Water","data":{"description#Description":"You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container.","example-1#Example 1:":"Input: height = [1,8,6,2,5,4,8,3,7]\n  Output: 49\n  Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.","example-2#Example 2:":"Input: height = [1,1]\n  Output: 1","constraints#Constraints:":"n == height.length\n2 <= n <= 10^5\n0 <= height[i] <= 10^4","solution-from-others#Solution from others":"// Solution using two pointers\n/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function(height) {\n    let maxArea = 0;\n    let left = 0; // leftmost bar graph\n    let right = height.length -1; // rightmost bar graph\n    while(left < right) {\n      // Base * Height\n      // need lower height because of the water will be overflowed\n      let currArea = (right - left) * Math.min(height[left], height[right]); \n      maxArea = Math.max(maxArea, currArea);\n      // maintain the side with the greater height and move the lower side by one step\n      if(height[left] < height[right]) {\n          left++;\n      } else {\n          right--;\n      }\n    }\n    return maxArea;\n};"}},"/leetcode/151-reverse-words-in-a-string":{"title":"151. Reverse Words in a String","data":{"description#Description":"Given an input string s, reverse the order of the words.A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.Return a string of the words in reverse order concatenated by a single space.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.","example-1#Example 1:":"Input: s = \"the sky is blue\"\n  Output: \"blue is sky the\"","example-2#Example 2:":"Input: s = \"  hello world  \"\n  Output: \"world hello\"\n  Explanation: Your reversed string should not contain leading or trailing spaces.","example-3#Example 3:":"Input: s = \"a good   example\"\n  Output: \"example good a\"\n  Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.","constraints#Constraints:":"1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.","my-solution#My Solution":"/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function(s) { \n    return s.trim().split(' ').filter(word => word.length > 0).reverse().join(' ');\n};"}},"/leetcode/1456-maximum-number-of-vowels-in-a-substring-of-given-length":{"title":"1456. Maximum Number of Vowels in a Substring of Given Length","data":{"description#Description":"Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.","example-1#Example 1:":"Input: s = \"abciiidef\", k = 3\n  Output: 3\n  Explanation: The substring \"iii\" contains 3 vowel letters.","example-2#Example 2:":"Input: s = \"aeiou\", k = 2\n  Output: 2\n  Explanation: Any substring of length 2 contains 2 vowels.","example-3#Example 3:":"Input: s = \"leetcode\", k = 3\n  Output: 2\n  Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels.","constraints#Constraints:":"1 <= s.length <= 10^5\ns consists of lowercase English letters.\n1 <= k <= s.length","my-solution#My Solution":"// using sliding window\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar maxVowels = function(s, k) {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let count = 0;\n    let maxCount = 0;\n    for(let i = 0; i < k; i++) {\n        if(vowels.includes(s[i])) count++;\n    }\n    maxCount = count;\n    for(let i = k; i < s.length; i++) {\n        if(vowels.includes(s[i-k])) count--;\n        if(vowels.includes(s[i])) count++;\n        maxCount = Math.max(maxCount, count);\n    }\n    return maxCount;\n};","explanation#Explanation":"Purpose: The goal is to find the maximum number of vowels in any substring of length 'k' from the given string 's'.\nVowel List: First, make a list of vowels ('a', 'e', 'i', 'o', 'u').\nStart Counting: Initialize two counters: 'count' for the current number of vowels, and 'maxCount' for the highest number of vowels found.\nFirst Window: Look at the first substring of length 'k'. For each character, if it's a vowel (in our list), increase 'count' by 1.\nSet Initial Max: After checking the first 'k' characters, set 'maxCount' to the value of 'count'.\nSlide the Window: Now, start sliding the window one character at a time, from the kth character to the end of the string 's'.\nSubtract: If the character leaving the window (on the left) is a vowel, reduce 'count' by 1.\nAdd: If the new character entering the window (on the right) is a vowel, increase 'count' by 1.\nUpdate Max: After each slide, update 'maxCount' if 'count' is higher than the current 'maxCount'.\nResult: Once slid through the entire string, 'maxCount' will hold the maximum number of vowels we could find in any substring of length 'k'. Return 'maxCount'."}},"/leetcode/1768-merge-strings-alternately":{"title":"1768. Merge Strings Alternately","data":{"description#Description":"You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.Return the merged string.","example-1#Example 1":"Input: word1 = \"abc\", word2 = \"pqr\"\n  Output: \"apbqcr\"\n  Explanation: The merged string will be merged as so:\n  word1:  a   b   c\n  word2:    p   q   r\n  merged: a p b q c r","example-2#Example 2":"Input: word1 = \"ab\", word2 = \"pqrs\"\n  Output: \"apbqrs\"\n  Explanation: Notice that as word2 is longer, \"rs\" is appended to the end.\n  word1:  a   b \n  word2:    p   q   r   s\n  merged: a p b q   r   s","example-3#Example 3":"Input: word1 = \"abcd\", word2 = \"pq\"\n  Output: \"apbqcd\"\n  Explanation: Notice that as word1 is longer, \"cd\" is appended to the end.\n  word1:  a   b   c   d\n  word2:    p   q \n  merged: a p b q c   d","constraints#Constraints":"1 <= word1.length, word2.length <= 100\nword1 and word2 consist of lowercase English letters.","my-solution#My Solution":"/**\n * @param {string} word1\n * @param {string} word2\n * @return {string}\n */\nvar mergeAlternately = function(word1, word2) {\n  let result = '';\n  let i;\n  // Loop through the length of the shortest word\n  for (i = 0; i < word1.length && i < word2.length; i++) {\n    result += word1[i] + word2[i];\n  }\n  // If there are any letters left in either word, add them to the result\n  if (i < word1.length) {\n    result += word1.slice(i);\n  } else if (i < word2.length) {\n    result += word2.slice(i);\n  }\n  return result;\n}"}},"/leetcode/1493-longest-subarray-of-1s-after-deleting-one-element":{"title":"1493. Longest Subarray of 1's After Deleting One Element","data":{"description#Description":"Given a binary array nums, you should delete one element from it.Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.","example-1#Example 1:":"Input: nums = [1,1,0,1]\n  Output: 3\n  Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.","example-2#Example 2:":"Input: nums = [0,1,1,1,0,1,1,0,1]\n  Output: 5\n  Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].","example-3#Example 3:":"Input: nums = [1,1,1]\nOutput: 2\nExplanation: You must delete one element.","constraints#Constraints:":"1 <= nums.length <= 10^5\nnums[i] is either 0 or 1.","my-solution#My Solution":"// using sliding window\n/**\n * @param {number[]} nums\n * @return {number}\n */\n var longestSubarray = function(nums) {\n  let left = 0;\n  let zeroCount = 0\n  let maxLen = 0;\n  for(let right = 0; right < nums.length; right++) {\n    if (nums[right] === 0) {\n      zeroCount++;\n    } \n    while (zeroCount > 1) {\n      // If the number of zeros exceeds one, move the left pointer to the right,\n      // reducing the number of zeros.\n      if (nums[left] === 0) {\n        zeroCount--;\n      }\n      left++;\n    }\n    // The current window's length is right - left + 1.\n    // However, according to the problem's condition that one element must be deleted,\n    // the actual length becomes right - left.\n    maxLen = Math.max(maxLen, right - left);\n  }\n  return maxLen;\n};","explanation#Explanation":"Initialize Variables: Start with two pointers, left and right, at the start of the array. left marks the beginning of the window, and right marks the end. Also, have a zeroCount to keep track of the zeros in the window, and a maxLength to store the longest sequence found.\nExpand Window: Move right pointer to the right (increase it) to make the window bigger. Every time you see a 0, increase zeroCount.\nCheck Zeros: If zeroCount is more than 1, it means there are too many zeros in our current window. We need only one or none.\nShrink Window: Start moving left pointer to the right (increase it) to make the window smaller from the left side. Do this until zeroCount is 1 or less again. If you pass a 0 while moving left, decrease zeroCount.\nCalculate Length: The current window length is the difference between right and left. Update maxLength if this length is the longest found so far.\nRepeat: Keep expanding the window by moving right until you've checked the whole array.\nReturn Result: The longest sequence length is maxLength. Remember, we subtract one from the window length because we're allowed to remove one 0"}},"/leetcode/283-move-zeroes":{"title":"283. Move Zeroes","data":{"description#Description":"Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.Note that you must do this in-place without making a copy of the array.","example-1#Example 1:":"Input: nums = [0,1,0,3,12]\n  Output: [1,3,12,0,0]","example-2#Example 2:":"Input: nums = [0]\n  Output: [0]","constraints#Constraints:":"1 <= nums.length <= 10^4\n2^31 <= nums[i] <= 2^31 - 1","my-solution-1#My Solution #1":"// Not quite accurate solution\n// need to use two pointers to solve this problem\n// Also bigO is O(n^2) (splice method is O(n) and the for loop is O(n))\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function(nums) {\n    for(let i = nums.length - 2; i >= 0; i--) {\n        if(nums[i] === 0) {\n            nums.splice(i,1);\n            nums.push(0);\n        }\n    }\n};","my-solution-2#My Solution #2":"// More accurate solution using two pointers\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function (nums) {\n  let i = 0;\n  let j = 1;\n  while (j < nums.length) {\n    // if the first pointer is not 0, move to the next element\n    if(nums[i] !== 0) { \n      i++;\n      j++;\n    } else {\n      // if the first pointer is 0 and the second pointer is not 0, swap the elements\n      if(nums[j] !== 0) {\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n        i++;\n      }\n      // if the second pointer is 0, move to the next element\n      j++;\n    }\n  }\n}"}},"/leetcode/238-product-of-array-except-self":{"title":"238. Product of Array Except Self","data":{"description#Description":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.You must write an algorithm that runs in O(n) time and without using the division operation.","example-1#Example 1:":"Input: nums = [1,2,3,4]\n  Output: [24,12,8,6]","example-2#Example 2:":"Input: nums = [-1,1,0,-3,3]\n  Output: [0,0,9,0,0]","constraints#Constraints:":"2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.","my-solution#My Solution":"// Failed: Time Limit Exceeded \n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function (nums) {\n  let answer = [];\n  for (let i = 0; i < nums.length; i++) {\n    let total = 1;\n    for (let j = 0; j < nums.length; j++) {\n      if (i !== j) {\n        total *= nums[j];\n      }\n    }\n    answer.push(total);\n  }\n  return answer\n}","solution-from-others#Solution from others":"// prefix product * suffix product === product of all elements except self\n// Time complexity: O(n)\nvar productExceptSelf = function(nums) {\n    const n = nums.length;\n    const answer = new Array(n);\n    answer[0] = 1;\n    // Calculate the product of all elements to the left of each element\n    for (let i = 1; i < n; i++) {\n        answer[i] = answer[i - 1] * nums[i - 1];\n    }\n    let rightProduct = 1;\n    // Calculate the product of all elements to the right of each element \n    // and multiply it with the previously computed product from the left\n    for (let i = n - 1; i >= 0; i--) {\n        answer[i] *= rightProduct;\n        rightProduct *= nums[i];\n    }\n    return answer;\n};"}},"/leetcode/1679-max-number-of-k-sum-pairs":{"title":"1679. Max Number of K-Sum Pairs","data":{"description#Description":"You are given an integer array nums and an integer k.In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.Return the maximum number of operations you can perform on the array.","example-1#Example 1:":"Input: nums = [1,2,3,4], k = 5\n  Output: 2\n  Explanation: Starting with nums = [1,2,3,4]:\n  - Remove numbers 1 and 4, then nums = [2,3]\n  - Remove numbers 2 and 3, then nums = []\n  There are no more pairs that sum up to 5, hence a total of 2 operations.","example-2#Example 2:":"Input: nums = [3,1,3,4,3], k = 6\n  Output: 1\n  Explanation: Starting with nums = [3,1,3,4,3]:\n  - Remove the first two 3's, then nums = [1,4,3]\n  There are no more pairs that sum up to 6, hence a total of 1 operation.","constraints#Constraints:":"1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9","my-solution#My Solution":"// using Two Pointers\nvar maxOperations = function (nums, k) {\n  nums.sort((a, b) => a - b);\n  let count = 0;\n  let left = 0;\n  let right = nums.length - 1;\n  while(left < right) {\n    if (nums[left] + nums[right] === k) {\n      count++;\n      left++;\n      right--;\n    } else if (nums[left] + nums[right] < k) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  return count;\n}","solution-from-others#Solution from others":"// using Hash Map\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maxOperations = function (nums, k) {\n  let map = new Map(); // A hashmap to store the frequency of each number\n  let count = 0;\n  for (let num of nums) {\n    let complement = k - num; // Calculate the complement of the current number that would sum up to k\n    // If the complement is in the hashmap and has a frequency greater than 0,\n    // it means we've found a pair. So, increase the count and decrease the frequency of the complement.\n    if (map.get(complement) > 0) {\n      count++;\n      map.set(complement, map.get(complement) - 1);\n    } else {\n      // If the complement is not present, add or update the current number's frequency in the hashmap.\n      map.set(num, (map.get(num) || 0) + 1);\n    }\n  }\n  return count;\n}"}},"/leetcode/334-increasing-triplet-subsequence":{"title":"334. Increasing Triplet Subsequence","data":{"description#Description":"Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.","example-1#Example 1:":"Input: nums = [1,2,3,4,5]\n  Output: true\n  Explanation: Any triplet where i < j < k is valid.","example-2#Example 2:":"Input: nums = [5,4,3,2,1]\n  Output: false\n  Explanation: No triplet exists.","example-3#Example 3:":"Input: nums = [2,1,5,0,4,6]\n  Output: true\n  Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.","constraints#Constraints:":"1 <= nums.length <= 5 * 10^5\n2^31 <= nums[i] <= 2^31 - 1","my-solution#My Solution":"// Failed: Time Limit Exceeded\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar increasingTriplet = function (nums) {\n  for (let i = 0; i < nums.length - 2; i++) {\n    let first = nums[i]\n    for (let j = i + 1; j < nums.length - 1; j++) {\n      let second\n      if (first < nums[j]) {\n        second = nums[j]\n      } else {\n        continue\n      }\n      for (let k = j + 1; k < nums.length; k++) {\n        if (second < nums[k]) {\n          return true\n        } else {\n          continue\n        }\n      }\n    }\n  }\n  return false\n}","solution-from-others#Solution from others":"var increasingTriplet = function (nums) {\n  let first = Infinity\n  let second = Infinity\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] <= first) {\n      first = nums[i]\n    } else if (nums[i] <= second) {\n      second = nums[i]\n    } else {\n      return true\n    }\n  }\n  return false\n}"}},"/leetcode/345-reverse-vowels-of-a-string":{"title":"345. Reverse Vowels of a String","data":{"description#Description":"Given a string s, reverse only all the vowels in the string and return it.The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.","example-1#Example 1:":"Input: s = \"hello\"\n  Output: \"holle\"","example-2#Example 2:":"Input: s = \"leetcode\"\n  Output: \"leotcede\"","constraints#Constraints:":"1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.","solution-from-others#Solution from others":"// using two pointers\n/**\n * @param {string} s\n * @return {string}\n */\nvar reverseVowels = function (s) {\n  const vowels = 'aeiouAEIOU';\n  let left = 0;\n  let right = s.length - 1;\n  let arr = s.split('');\n  \n  while (left < right) {\n    // find the vowels from the left\n    if (!vowels.includes(arr[left])) {\n      left++;\n      continue;\n    }\n    // find the vowels from the right\n    if (!vowels.includes(arr[right])) {\n      right--;\n      continue;\n    }\n    // swap the vowels using destructuring assignment\n    [arr[left], arr[right]] = [arr[right], arr[left]];\n    left++;\n    right--;\n  }\n  return arr.join('');\n}"}},"/leetcode/443-string-compression":{"title":"443. String Compression","data":{"description#Description":"Given an array of characters chars, compress it using the following algorithm:Begin with an empty string s. For each group of consecutive repeating characters in chars:\nIf the group's length is 1, append the character to s.\nOtherwise, append the character followed by the group's length.\nThe compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.After you are done modifying the input array, return the new length of the array.You must write an algorithm that uses only constant extra space.","example-1#Example 1:":"Input: chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n  Output: Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\n  Explanation: The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\".","example-2#Example 2:":"Input: chars = [\"a\"]\n  Output: Return 1, and the first character of the input array should be: [\"a\"]\n  Explanation: The only group is \"a\", which remains uncompressed since it's a single character.","example-3#Example 3:":"Input: chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\n  Output: Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\n  Explanation: The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".","constraints#Constraints:":"1 <= chars.length <= 2000\nchars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.","solution-from-others#Solution from others":"/*\n  This solution uses two pointers i and j to iterate through the input array. \n  The variable count keeps track of the number of consecutive characters \n  that are equal to the current character curr. When a new character is encountered, \n  the current character and its count (if greater than 1) are written \n  to the output array using the chars array and the i pointer.\n  Finally, the function returns i, which represents the length of the compressed array.\n*/\n/**\n * @param {character[]} chars\n * @return {number}\n */\nvar compress = function(chars) {\n    let i = 0;\n    let j = 0;\n    while (j < chars.length) {\n        let count = 0;\n        let curr = chars[j];\n        while (j < chars.length && chars[j] === curr) {\n            j++;\n            count++;\n        }\n        chars[i++] = curr;\n        if (count > 1) {\n            for (let digit of count.toString()) {\n                chars[i++] = digit;\n            }\n        }\n    }\n    return i;\n};"}},"/leetcode/605-can-place-flowers":{"title":"605. Can Place Flowers","data":{"description#Description":"You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.","example-1#Example 1:":"Input: flowerbed = [1,0,0,0,1], n = 1\n  Output: true","example-2#Example 2:":"Input: flowerbed = [1,0,0,0,1], n = 2\n  Output: false","constraints#Constraints:":"1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length","my-solution#My Solution":"/**\n * @param {number[]} flowerbed\n * @param {number} n\n * @return {boolean}\n */\nvar canPlaceFlowers = function(flowerbed, n) {\n  let cnt = 0;\n  // if there is only one plot and it is empty and n is 1\n  if(flowerbed.length == 1 && flowerbed[0] === 0 && n === 1) {\n      return true\n  }\n  for(let i = 0; i < flowerbed.length; i++) {\n    // if the first plot is empty and the next plot is empty\n    if(i === 0 && flowerbed[i] === 0 && flowerbed[i+1] === 0) {\n        flowerbed[i] = 1;\n        cnt++;\n    // if the plot is empty and the previous plot is empty and the next plot is empty\n    } else if (flowerbed[i] === 0 && flowerbed[i-1] === 0 && flowerbed[i+1] === 0) {\n        flowerbed[i] = 1;\n        cnt++\n    // if the last plot is empty and the previous plot is empty\n    } else if (i === flowerbed.length -1 && flowerbed[i] === 0 && flowerbed[i-1] === 0) {\n        flowerbed[i] = 1;\n        cnt++\n    }\n  }\n  // if the count of new flowers is greater than or equal to n\n  return cnt >= n;\n};","solution-from-others#Solution from others":"// The solution is similar to mine, but it is more concise and efficient.\nvar canPlaceFlowers = function(flowerbed, n) {\n  let count = 0;\n  for(let i = 0; i < flowerbed.length; i++) {\n      if(flowerbed[i] === 0 && (i === 0 || flowerbed[i-1] === 0) \n        && (i === flowerbed.length - 1 || flowerbed[i+1] === 0)) {\n          flowerbed[i] = 1;\n          count++;\n      }\n  }\n  return count >= n;\n};","explanation#Explanation":"Start Counting: Begin with a count of 0. This will track how many flowers we can plant.\nLoop Through: Go through each spot in the flowerbed one by one.\nCheck Conditions: For each spot, check three things:\nIf the current spot is empty (0 means no flower there).\nIf the spot to the left is empty or it's the first spot in the flowerbed.\nIf the spot to the right is empty or it's the last spot in the flowerbed.\nPlant Flower: If all conditions are met (the spot is empty and both adjacent spots are empty or edges), plant a flower there (change 0 to 1) and increase your count by 1.\nRepeat: Keep doing this for every spot in the flowerbed.\nFinal Check: In the end, see if the count of flowers you planted is equal to or more than 'n', the number of flowers you wanted to plant.\nResult: Return true if you could plant at least 'n' flowers without breaking the rules; otherwise, return false.","note#Note":"In JavaScript, negative index is not allowed. It will return undefined. If you want to check the last element of an array, you can use array[array.length - 1] instead of array[-1]."}},"/react/01-attribute-conversion":{"title":"HTML Attribute Conversion: From HTML to JSX","data":{"":"HTML Attribute\tJSX Attribute\tUsed in HTML Tags\tclass\tclassName\tAll HTML tags\tfor\thtmlFor\tlabel, output\tonchange\tonChange\tinput, select, textarea\tonclick\tonClick\tAll clickable tags (e.g., button, a)"}},"/leetcode/392-is-subsequence":{"title":"392. Is Subsequence","data":{"description#Description":"Given two strings s and t, return true if s is a subsequence of t, or false otherwise.A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).","example-1#Example 1:":"Input: s = \"abc\", t = \"ahbgdc\"\n  Output: true","example-2#Example 2:":"Input: s = \"axc\", t = \"ahbgdc\"\n  Output: false","constraints#Constraints:":"0 <= s.length <= 100\n- 0 <= t.length <= 10^4\ns and t consist only of lowercase English letters.","my-solution#My Solution":"// Solution using Two pointers\n/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isSubsequence = function (s, t) {\n  let i = 0;\n  let j = 0;\n  while(i < s.length && j < t.length) {\n    if(s[i] === t[j]) i++;\n    j++;\n  }\n  return i === s.length;\n}"}},"/leetcode/643-maximum-average-subarray-i":{"title":"643. Maximum Average Subarray I","data":{"description#Description":"You are given an integer array nums consisting of n elements, and an integer k.Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10^-5 will be accepted.","example-1#Example 1:":"Input: nums = [1,12,-5,-6,50,3], k = 4\n  Output: 12.75000\n  Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75","example-2#Example 2:":"Input: nums = [5], k = 1\n  Output: 5.00000","constraints#Constraints:":"n == nums.length\n1 <= k <= n <= 10^5\n-10^4 <= nums[i] <= 10^4","my-solution#My Solution":"// failed: Time Limit Exceeded\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findMaxAverage = function (nums, k) {\n  let maxAverage = 0\n  if (nums.length === 1) {\n    return nums[0];\n  }\n  for (let i = 0; i <= nums.length - k; i++) {\n    let sum = 0\n    for (let j = i; j < k + i; j++) {\n      sum += nums[j]\n    }\n    if (i === 0) {\n      maxAverage = sum / k\n    } else {\n      maxAverage = Math.max(maxAverage, sum / k)\n    }\n  }\n  return maxAverage\n}","solution-from-others#Solution from others":"// using sliding window\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findMaxAverage = function(nums, k) {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += nums[i];\n  }\n  \n  let max = sum;\n  for (let i = k; i < nums.length; i++) {\n    // Subtract the element leaving the window and \n    // add the new element entering the window.\n    sum = sum - nums[i - k] + nums[i];\n    max = Math.max(max, sum);\n  }\n  \n  return max / k;\n};","explanation#Explanation":"Start Sum: First, add up the first 'k' numbers to get a starting sum.\nInitial Max: Keep this sum as the initial highest sum.\nSliding Window: Imagine a moving window that covers 'k' numbers in the array.\nMove Window: Each time, move the window one number to the right.\nUpdate Sum: Subtract the number that's left behind and add the new number into the sum.\nCheck Max: Compare the new sum with the highest sum found so far. If it's higher, make this the new highest sum.\nRepeat: Keep moving the window and updating the sum until you reach the end of the array.\nCalculate Average: Divide the highest sum by 'k' to find the highest average.\nDone: Now, you have the highest average of 'k' consecutive numbers."}}}